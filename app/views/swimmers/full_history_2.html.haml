= render( partial: 'tabs_and_radio_title' )
- cache( cache_key_for_swimmer( 'full_history_2', @swimmer.id, @max_updated_at ) ) do
  - pool_type_25 = PoolType.find_by_code('25').i18n_verbose
  - pool_type_50 = PoolType.find_by_code('50').i18n_verbose
  .row-fluid#full_history_by_date_grid
    .goggles-category-gap#pageTop
    %table.table.table-striped.table-bordered.table-hover.table-condensed
      %tbody
        %tr{'class'=>'info'}
          %td
            %b= I18n.t('index')
          %td
            %b= pool_type_25
          %td
            %b= pool_type_50
        - @index_table.each do |index_row|
          %tr
            %td
              %b= index_row[:stroke_type]
            %td
              - if index_row[pool_type_25].respond_to?(:each)
                - index_row[pool_type_25].each do |event_type|
                  %a(href="##{event_type}#{index_row[:stroke_code]}-25")= event_type
            %td
              - if index_row[pool_type_50].respond_to?(:each)
                - index_row[pool_type_50].each do |event_type|
                  %a(href="##{event_type}#{index_row[:stroke_code]}-50")= event_type
    - event_key = nil
    %script
      var dataSeries = {};

    - @full_history_by_event.each do |full_history_key, full_history_element|
      - if full_history_element[1].respond_to?(:size) && full_history_element[1].size > 0
        -# Draw a graph placeholder for every different/new style-stroke pair:
        - if event_key.nil? || ( !event_key.nil? && (full_history_key =~ Regexp.new(event_key)).nil? )
          -# Extract a less detailed event key, removing length from the current detailed key:
          - event_key = full_history_key.gsub(/-25|-50/,'')
          - event_name = full_history_element[3].split(" - ")[0]
          -# Get the data for the graph:
          - event_data = full_history_element[4].map{ |mir| [mir.get_scheduled_date.to_datetime.to_i * 1000, mir.get_timing_instance.to_hundreds] }
          .row-fluid.goggles-category-gap
          .row-fluid.offset5
            %b= event_name
            %a{ href: "#pageTop", 'data-toggle'=>'tooltip', 'title'=>I18n.t('top_of_page') }= image_tag('bullet_arrow_up.png')
          .row-fluid.graph-container-full
            .graph-placeholder-full{ 'id' => "graph#{event_key}" }
          -# Store data for the graph in a brand new series list:
          %script
            dataSeries[ "#{ event_key }" ] = []
            dataSeries[ "#{ event_key }" ].push( { label: "#{ full_history_element[3] }", data: JSON.parse("#{ escape_javascript( event_data.to_json ) }") } );
            // console.log( dataSeries[ "#{ event_key }" ] );
        - else
          -# Get the data for the graph:
          - event_data = full_history_element[4].map{ |mir| [mir.get_scheduled_date.to_datetime.to_i * 1000, mir.get_timing_instance.to_hundreds] }
          -# Append data for the graph in the existing variable:
          %script
            dataSeries[ "#{ event_key }" ].push( { label: "#{ full_history_element[3] }", data: JSON.parse("#{ escape_javascript( event_data.to_json ) }") } );
            // console.log( dataSeries[ "#{ event_key }" ] );
          - event_key = nil

        .row-fluid
          .goggles-category-gap{ 'id' => "#{full_history_key}" }
          %table.table.table-striped.table-bordered.table-hover.table-condensed
            %tbody
              %tr{'class'=>'info'}
                %td
                  %b= full_history_element[3]
                  = ' ('
                  = full_history_element[1].size if full_history_element[1].respond_to?(:size)
                  = I18n.t('results') + ')'
                  %a{ href: "#pageTop", 'data-toggle'=>'tooltip', 'title'=>I18n.t('top_of_page') }= image_tag('bullet_arrow_up.png')
                %td.goggles-rightalign
                  %b= I18n.t('meeting.reaction_time')
                - passage_list = full_history_element[0]
                - if passage_list.respond_to?(:each)
                  - passage_list.each do |passage_code|
                    %td.goggles-centeralign
                      %b= passage_code
                %td.goggles-rightalign
                  %b= I18n.t('meeting.timing')
                %td.goggles-rightalign
                  %b= I18n.t('meeting.fin_score')
                %td.goggles-rightalign
                  %b= I18n.t('meeting.rank')

              - if full_history_element[1].respond_to?(:each)
                - full_history_element[1].each do |meeting_individual_result|
                  - meeting = meeting_individual_result.meeting
                  - passages = full_history_element[2].where(meeting_individual_result: meeting_individual_result) if full_history_element[2].respond_to?(:where)
                  = render( partial: 'full_history_by_time_meeting_row', locals: { meeting_individual_result: meeting_individual_result, passage_list: passage_list, meeting: meeting, passages: passages } )

  .row-fluid.goggles-category-gap

  :javascript
    // Custom label formatter:
    function tickFormatter(val, axis) {
      var hours     = Math.floor( val / 360000 );
      var remainder = Math.floor( val % 360000 );
      var minutes   = Math.floor( remainder / 6000 );
      remainder     = Math.floor( remainder % 6000 );
      var seconds   = Math.floor( remainder / 100 );
      var hundreds  = Math.floor( remainder % 100 );
      var label     = ( hours > 0 ? hours + "h " : "" );
      seconds = seconds.toString().length < 2 ? "0" + seconds : seconds;
      hundreds = hundreds.toString().length < 2 ? "0" + hundreds : hundreds;
      if ( minutes > 0 ) {
        label += minutes + "'" + seconds + "\"" + hundreds;
      }
      else {
        label += seconds + "\"" + hundreds;
      }
      return label;
    }

    $( function() {
        var eventKeys = Object.keys( dataSeries );
        var options = {
            xaxis: {
              mode: "time",
              timeformat: "#{ Date::DATE_FORMATS[I18n.locale] }"
            },
            yaxis: {
              transform: function (v) { return -v; },
              inverseTransform: function (v) { return -v; },
              tickFormatter: tickFormatter
            },
            series: {
              lines: {
                show: true,
                label: {
                  show: true,
                }
              },
              points: {
                show: true
              }
            },
            grid: {
              hoverable: true
            },
            legend: {
              show: true,
              position: "sw"
            }
        };

        $( "<div id='tooltip'></div>" ).css({
          position: "absolute",
          display: "none",
          border: "1px solid #fdd",
          padding: "2px",
          "background-color": "#fee",
          opacity: 0.80
        }).appendTo( "body" );

        // Plot each graph:
        for ( index = 0; index < eventKeys.length; index++ ) {
          var currKey = eventKeys[index];
          $.plot( "#graph" + currKey, dataSeries[ currKey ], options );

          $("#graph" + currKey).bind( "plothover", function (event, pos, item) {
            if (item) {
              // console.log( item );
              var x = new Date( item.datapoint[0] ).toLocaleDateString();
              var y = tickFormatter( item.datapoint[1].toFixed(2) );
              $("#tooltip").html(
                y + ", " + x
              ).css( { top: item.pageY+5, left: item.pageX+5 } )
               .fadeIn(200);
            }
          } );
        }
      }
    );
