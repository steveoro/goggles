.span4
  .control-group
    = label_tag( :local_swimmer, t('misc.local_swimmer'), :for => :local_swimmer, class: 'control-label' )
    .controls
      .ui-widget.text-left
        = hidden_field( :local_swimmer, :id, value: (@local_swimmer ? @local_swimmer.id : nil) )
        = text_field_tag( :local_swimmer_name, (@local_swimmer ? @local_swimmer.complete_name : nil), |
            {autocomplete: 'off', class: "input-large typeahead",                                    |
            "data-provide"=>"typeahead", placeholder: I18n.t('combobox_3char_tooltip')} )             |
.span1
.span4
  .control-group
    = label_tag( :visitor_swimmer, t('misc.visitor_swimmer'), :for => :visitor_swimmer, class: 'control-label' )
    .controls
      .ui-widget.text-left
        = hidden_field( :visitor_swimmer, :id )
        = text_field_tag( :visitor_swimmer_name, nil, {autocomplete: 'off', class: "input-large typeahead",  |
            "data-provide"=>"typeahead", placeholder: I18n.t('combobox_3char_tooltip')} )                     |

:javascript
  /* Lopk-up function for IDs stored in the list of result objects */
  function lookupIdInResultListByName( name, resultList ) {
    for ( var j = 0; j < resultList.length; j++ ) {
      if ( resultList[j].complete_name.match( name ) )
        return resultList[j].id;
    }
    return -1;
  }

  // (Wait for the page to be ready)
  $(function() {
    var resultList = [];

    // Define the typeahead callback handlers:
    $( ".typeahead" ).typeahead({
      items:     20,
      minLength: 3,

      source: function( queryText, processResults ) {
        // DEBUG
        //console.log( "get Ajax swimmers queryText: ", queryText );
        //console.log( this.$element );
        return $.get(
          "#{ api_v1_swimmers_path() }",
          { q: queryText },
          function (data) {
            //console.log( "returning data:", data );
            // Clear & rebuild the result list and the list of searchable names:
            resultList = [];
            var searchables = [];
            for ( idx = 0; idx < data.length; idx++ ) {
              var verboseName = data[idx].complete_name + " (" + data[idx].year_of_birth + ")";
              resultList.push({ id: data[idx].id, complete_name: verboseName });
              searchables.push( verboseName );
            };
            // DEBUG
            //console.log( "resultList:", resultList );
            //console.log( "searchables:", searchables );
            return processResults( searchables );
        });
      },

      updater: function( matchedText ) {
        // DEBUG
        //console.log( "getChosenSwimmer matchedText: ", matchedText );
        //console.log( this.$element.context.id );
        // Extract just the name part (brakets will mess up with Regexp.match
        var remote_id = lookupIdInResultListByName( matchedText.split("(")[0], resultList );
        //console.log( "remote_id: ", remote_id );
        if ( this.$element.context.id == "local_swimmer_name" )
          $("#local_swimmer_id").val( remote_id );
        else
          $("#visitor_swimmer_id").val( remote_id );
        return matchedText;
      }
    });

  });
